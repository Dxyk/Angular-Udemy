# Section 20 Authentication & Route Protection in Angular

## Authentication

### Lesson 286 - Module Introduction

Goal: Add authentication to the Angular application so that all of or part of the application is locked down if the user is not authenticated

### Lesson 287 - How Authentication Works

Authentication logic should be stored in the server because the client JS code is exposed to the users.

To authenticate a user, the front end sends the authentication info to the server through the server's API.

For applications where client and server is coupled, the server might return a session.

However, in a decoupled application, for RESTful or GraphQL server, since they are restless, they do not store sessions since they don't care about the client app. Instead, the server generates a JWT (Javascript Web Token), which is an encoded string generated by the server using a certain algorithm with a certain key, which only the server knows.

The client will store this JWT in the local storage (browser), and attach this token whenever it makes a request. The server will check this token for validation and fail the request if the token is invalid or if the client is not authorized.

Note the client cannot attempt to generate or modify the JWT because it will not match the server's algorithm or private key, thus server can therefore determine the token is invalid and block access to the request.

### Lesson 288 - Adding the Auth Page

Goal:

- Add a auth page where the user can log in or sign up. This page will not be mandatory since users who do not log in should also be able to access part of the page.
- Lock the recipes page if the user is not logged in.

To create the auth component

```sh
ng g c auth
```

In `auth.component.html`

- Add a form that contains
  - THe email label and input
  - The password label and input
  - The sign up button
  - The switch button

```html
<form>
  <div class="form-group">
    <label for="email">E-Mail</label>
    <input type="email" id="email" class="form-control" />
  </div>
  <div class="form-group">
    <label for="password">Password</label>
    <input type="password" id="password" class="form-control" />
  </div>
  <div>
    <button class="btn btn-primary">Sign Up</button> |
    <button class="btn btn-primary">Switch to Login</button>
  </div>
</form>
```

In `app-routing.module.ts`

- Register the `AuthComponent` to the `/auth` route

```ts
const appRoutes: Routes = [
  ...,
  {
    path: 'auth',
    component: AuthComponent,
  },
]
```

In `header.component.html`

- Provide a link in the header to navigate to the auth route

```html
<li routerLinkActive="active">
  <a routerLink="/auth">Authenticate</a>
</li>
```

### Lesson 289 - Switching Between Auth Modes

Track login / sign up modes and display button text correctly

In `auth.component.ts`

- Track the auth mode using a boolean
- Update the mode when the switch button is clicked

```ts
import { ... } from '...';

@Component({ ... })
export class AuthComponent implements OnInit {
  isLoginMode = true;

  onSwitchMode(): void {
    this.isLoginMode = !this.isLoginMode;
  }
}
```

In `auth.component.html`

- Use string interpolation to display the button text correctly
- Assign the correct button types

```html
<div>
  <button class="btn btn-primary" type="submit">
    {{ this.isLoginMode ? 'Login' : 'Sign Up'}}
  </button>
  |
  <button class="btn btn-primary" type="button" (click)="onSwitchMode()">
    Switch to {{ this.isLoginMode ? 'Sign Up' : 'Login'}}
  </button>
</div>
```

### Lesson 290 - Handling Form Input

Use the template driven approach to handle the forms.

In `auth.component.ts`

- Create a `onSubmit` method that logs the form and clears the form

```ts
import { ... } from '...';

@Component({ ... })
export class AuthComponent implements OnInit {
  ...
  onSubmit(authForm: NgForm): void {
    console.log(authForm.value);
    authForm.reset();
  }
}
```

In `auth.component.html`

- Bind the form to `onSubmit`
- Assign the form to `ngForm` using local reference
- Add necessary validators
- Disable the button if the form is invalid

```html
<form #authForm="ngForm" (ngSubmit)="onSubmit(authForm)">
  <input
    type="email"
    id="email"
    class="form-control"
    ngModel
    name="email"
    required
    email
  />
  <input
    type="password"
    id="password"
    class="form-control"
    ngModel
    name="password"
    required
    minlength="6"
  />
  <button class="btn btn-primary" type="submit" [disabled]="!authForm.valid">
    {{ this.isLoginMode ? 'Login' : 'Sign Up'}}
  </button>
</form>
```

### Lesson 291 - Preparing the Backend

To set up Firebase authentication backend

1. Go to the Realtime Database page

   1. In the Rules tab, change the rules to the following to disallow unauthenticated users to read or write to the database.

      ```json
      {
        "rules": {
          ".read": "auth != null",
          ".write": "auth != null"
        }
      }
      ```

   2. Now if an unauthenticated user tries to access the database, Firebase will throw a 401 Unauthorized Error

2. Go to the Authentication page

   1. Set up sign-in method
   2. Enable Email and Password
   3. Now We are able to send a request containing the email password information to Firebase to register users and authenticate them.
   4. All users can be viewed in the Users tab

### Lesson 292 - Make sure you got Recipes in your backend

Make sure the recipes collection in the database exists

### Lesson 293 - Preparing the Sign-up Request

From the [Firebase Auth REST API documentation](https://firebase.google.com/docs/reference/rest/auth), we get the

- Sign-up endpoint

  ```text
  https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=[API_KEY]
  ```

  - With request body

    - email: string
    - password: string
    - returnSecureToken: boolean

  - With return response

    - idToken: string
    - email: string
    - refreshToken: string
    - expiresIn: string
    - localId: string

- Sign-in endpoint

  ```text
  https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=[API_KEY]
  ```

  - With request body

    - email: string
    - password: string
    - returnSecureToken: boolean

  - With return response

    - idToken: string
    - email: string
    - refreshToken: string
    - expiresIn: string
    - localId: string
    - registered: boolean

To obtain the API_KEY, go to Firebase console, Project Settings, Web API key

Create an `AuthService` class

- Define the `AuthResponseData` that will be returned by Firebase auth endpoint
- Create a `signUp` method that
  - Posts to the Firebase sign up url
  - With `email`, `password` and `returnSecureToken` properties set.
  - Return the `Observable` object of type `AuthResponseData`

```ts
import { ... } from '...';

interface AuthResponseData {
  idToken: string;
  email: string;
  refreshToken: string;
  expiresIn: string;
  localId: string;
  registered?: boolean;
}

@Injectable({ providedIn: 'root' })
export class AuthService {
  constructor(private http: HttpClient) {}

  signUp(email: string, password: string): Observable<AuthResponseData> {
    return this.http.post<AuthResponseData>(FirebaseConfigs.SIGN_UP_URL, {
      email: email,
      password: password,
      returnSecureToken: true,
    });
  }
}
```
