# Section 20 Authentication & Route Protection in Angular

## Authentication

### Lesson 286 - Module Introduction

Goal: Add authentication to the Angular application so that all of or part of the application is locked down if the user is not authenticated

### Lesson 287 - How Authentication Works

Authentication logic should be stored in the server because the client JS code is exposed to the users.

To authenticate a user, the front end sends the authentication info to the server through the server's API.

For applications where client and server is coupled, the server might return a session.

However, in a decoupled application, for RESTful or GraphQL server, since they are restless, they do not store sessions since they don't care about the client app. Instead, the server generates a JWT (Javascript Web Token), which is an encoded string generated by the server using a certain algorithm with a certain key, which only the server knows.

The client will store this JWT in the local storage (browser), and attach this token whenever it makes a request. The server will check this token for validation and fail the request if the token is invalid or if the client is not authorized.

Note the client cannot attempt to generate or modify the JWT because it will not match the server's algorithm or private key, thus server can therefore determine the token is invalid and block access to the request.

### Lesson 288 - Adding the Auth Page

Goal:

- Add a auth page where the user can log in or sign up. This page will not be mandatory since users who do not log in should also be able to access part of the page.
- Lock the recipes page if the user is not logged in.

To create the auth component

```sh
ng g c auth
```

In `auth.component.html`

- Add a form that contains
  - THe email label and input
  - The password label and input
  - The sign up button
  - The switch button

```html
<form>
  <div class="form-group">
    <label for="email">E-Mail</label>
    <input type="email" id="email" class="form-control" />
  </div>
  <div class="form-group">
    <label for="password">Password</label>
    <input type="password" id="password" class="form-control" />
  </div>
  <div>
    <button class="btn btn-primary">Sign Up</button> |
    <button class="btn btn-primary">Switch to Login</button>
  </div>
</form>
```

In `app-routing.module.ts`

- Register the `AuthComponent` to the `/auth` route

```ts
const appRoutes: Routes = [
  ...,
  {
    path: 'auth',
    component: AuthComponent,
  },
]
```

In `header.component.html`

- Provide a link in the header to navigate to the auth route

```html
<li routerLinkActive="active">
  <a routerLink="/auth">Authenticate</a>
</li>
```

### Lesson 289 - Switching Between Auth Modes

Track login / sign up modes and display button text correctly

In `auth.component.ts`

- Track the auth mode using a boolean
- Update the mode when the switch button is clicked

```ts
import { ... } from '...';

@Component({ ... })
export class AuthComponent implements OnInit {
  isLoginMode = true;

  onSwitchMode(): void {
    this.isLoginMode = !this.isLoginMode;
  }
}
```

In `auth.component.html`

- Use string interpolation to display the button text correctly
- Assign the correct button types

```html
<div>
  <button class="btn btn-primary" type="submit">
    {{ this.isLoginMode ? 'Login' : 'Sign Up'}}
  </button>
  |
  <button class="btn btn-primary" type="button" (click)="onSwitchMode()">
    Switch to {{ this.isLoginMode ? 'Sign Up' : 'Login'}}
  </button>
</div>
```

### Lesson 290 - Handling Form Input

Use the template driven approach to handle the forms.

In `auth.component.ts`

- Create a `onSubmit` method that logs the form and clears the form

```ts
import { ... } from '...';

@Component({ ... })
export class AuthComponent implements OnInit {
  ...
  onSubmit(authForm: NgForm): void {
    console.log(authForm.value);
    authForm.reset();
  }
}
```

In `auth.component.html`

- Bind the form to `onSubmit`
- Assign the form to `ngForm` using local reference
- Add necessary validators
- Disable the button if the form is invalid

```html
<form #authForm="ngForm" (ngSubmit)="onSubmit(authForm)">
  <input
    type="email"
    id="email"
    class="form-control"
    ngModel
    name="email"
    required
    email
  />
  <input
    type="password"
    id="password"
    class="form-control"
    ngModel
    name="password"
    required
    minlength="6"
  />
  <button class="btn btn-primary" type="submit" [disabled]="!authForm.valid">
    {{ this.isLoginMode ? 'Login' : 'Sign Up'}}
  </button>
</form>
```

### Lesson 291 - Preparing the Backend

To set up Firebase authentication backend

1. Go to the Realtime Database page

   1. In the Rules tab, change the rules to the following to disallow unauthenticated users to read or write to the database.

      ```json
      {
        "rules": {
          ".read": "auth != null",
          ".write": "auth != null"
        }
      }
      ```

   2. Now if an unauthenticated user tries to access the database, Firebase will throw a 401 Unauthorized Error

2. Go to the Authentication page

   1. Set up sign-in method
   2. Enable Email and Password
   3. Now We are able to send a request containing the email password information to Firebase to register users and authenticate them.
   4. All users can be viewed in the Users tab

### Lesson 292 - Make sure you got Recipes in your backend

Make sure the recipes collection in the database exists

### Lesson 293 - Preparing the Sign-up Request

From the [Firebase Auth REST API documentation](https://firebase.google.com/docs/reference/rest/auth), we get the

- Sign-up endpoint

  ```text
  https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=[API_KEY]
  ```

  - With request body

    - email: string
    - password: string
    - returnSecureToken: boolean

  - With return response

    - idToken: string
    - email: string
    - refreshToken: string
    - expiresIn: string
    - localId: string

- Sign-in endpoint

  ```text
  https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key=[API_KEY]
  ```

  - With request body

    - email: string
    - password: string
    - returnSecureToken: boolean

  - With return response

    - idToken: string
    - email: string
    - refreshToken: string
    - expiresIn: string
    - localId: string
    - registered: boolean

To obtain the API_KEY, go to Firebase console, Project Settings, Web API key

Create an `AuthService` class

- Define the `AuthResponseData` that will be returned by Firebase auth endpoint
- Create a `signUp` method that
  - Posts to the Firebase sign up url
  - With `email`, `password` and `returnSecureToken` properties set.
  - Return the `Observable` object of type `AuthResponseData`

```ts
import { ... } from '...';

interface AuthResponseData {
  idToken: string;
  email: string;
  refreshToken: string;
  expiresIn: string;
  localId: string;
  registered?: boolean;
}

@Injectable({ providedIn: 'root' })
export class AuthService {
  constructor(private http: HttpClient) {}

  signUp(email: string, password: string): Observable<AuthResponseData> {
    return this.http.post<AuthResponseData>(FirebaseConfigs.SIGN_UP_URL, {
      email: email,
      password: password,
      returnSecureToken: true,
    });
  }
}
```

### Lesson 294 - Sending the Sign-up Request

In `auth.component.ts`

- Get the email password fields from the form
- Make the sign-up request using the auth service
  - Handle the response or error by logging to the console for now

```ts
import { ... } from '...';

@Component({ ... })
export class AuthComponent implements OnInit {
  ...
  onSubmit(authForm: NgForm): void {
    if (!authForm.valid) {
      return;
    } else {
      const email = authForm.value.email;
      const password = authForm.value.password;

      if (this.isLoginMode) {
      } else {
        this.authService.signUp(email, password).subscribe(
          (responseData: AuthResponseData) => {
            console.log(responseData);
          },
          (error: any) => {
            console.log(error);
          }
        );
      }

      authForm.reset();
    }
  }
}
```

### Lesson 295 - Adding a Loading Spinner & Error Handling Logic

To add the loading spinner

1. Create a loading-spinner component in the shared directory.
   1. `ng g c shared/loading-spinner`
2. Find a pure css script for a loading spinner template online
   1. E.g. https://loading.io/css/
3. Copy-paste the CSS template into the `loading-spinner.component.css` file
4. Copy-paste the HTML template into the `loading-spinner.component.html` file

In the auth component, we want to hide the entire form when the request is in flight.

In `auth.component.ts`

- Set `isLoading` when a request is in flight, and unset when the request is done
- Set `error` when the request fails

```ts
import { ... } from '...';

@Component({ ... })
export class AuthComponent implements OnInit {
  isLoading = false;
  error: string = null;
  ...
  onSubmit(authForm: NgForm): void {
    if (!authForm.valid) {
      return;
    } else {
      ...
      this.isLoading = true;
      if (this.isLoginMode) {
        this.isLoading = false;
      } else {
        this.authService.signUp(email, password).subscribe(
          (responseData: AuthResponseData) => {
            ...
            this.isLoading = false;
          },
          (error: any) => {
            ...
            this.error = 'An error occurred';
            this.isLoading = false;
          }
        );
      }
      ...
    }
  }
}
```

In `auth.component.html`

- An alert text box that only appears when the error is not null
- A spinner div that only appears when a request is in flight

```html
<div class="alert alert-danger" *ngIf="error">
  <p>{{ error }}</p>
</div>

<div class="spinner" *ngIf="isLoading">
  <app-loading-spinner></app-loading-spinner>
</div>

<form
  #authForm="ngForm"
  (ngSubmit)="onSubmit(authForm)"
  *ngIf="!isLoading"
></form>
```

### Lesson 296 - Improving Error Handling

To make the error message more specific, we can leverage the error message returned by Firebase.

In `auth.service.ts`

- Handle the error and extract the error message using RxJS `catchError` operator and `throwError` method

```ts
import { ... } from '...';

@Injectable({ providedIn: 'root' })
export class AuthService {
  constructor(private http: HttpClient) {}

  signUp(email: string, password: string): Observable<AuthResponseData> {
    return this.http
      .post<AuthResponseData>(...)
      .pipe(
        catchError((error: any) => {
          let errorMessage = 'An unknown error occurred!';
          if (error?.error?.error) {
            switch (error.error.error.message) {
              case 'EMAIL_EXISTS': {
                errorMessage = 'This email already exists!';
              }
            }
          }
          return throwError(errorMessage);
        })
      );
  }
}
```

In `app.component.ts`

- Handle the extracted error message thrown by the `AuthService`

```ts
import { ... } from '...';

@Component({ ... })
export class AuthComponent implements OnInit {
  ...
  onSubmit(authForm: NgForm): void {
    if (!authForm.valid) {
      return;
    } else {
      ...
      if (this.isLoginMode) {
        this.isLoading = false;
      } else {
        this.authService.signUp(email, password).subscribe(
          (responseData: AuthResponseData) => { ... },
          errorMessage: string) => {
            console.log(errorMessage);
            this.error = errorMessage;
            this.isLoading = false;
          }
        );
      }
      ...
    }
  }
}
```

### Lesson 297 - Sending Login Requests

In `auth.service.ts`

- Create a `login` method that sends a post request to Firebase to log the user in

```ts
import { ... } from '...';

@Injectable({ providedIn: 'root' })
export class AuthService {
  constructor(private http: HttpClient) {}

  login(email: string, password: string): Observable<AuthResponseData> {
    return this.http
      .post<AuthResponseData>(FirebaseConfigs.SIGN_IN_URL, {
        email: email,
        password: password,
        returnSecureToken: true,
      });
  }
}
```

In `auth.component.ts`

- Use an observable variable to avoid writing duplicated code
- Call the `AuthService.login` method to allow the user to sign in

```ts
import { ... } from '...';

@Component({ ... })
export class AuthComponent implements OnInit {
  ...
  onSubmit(authForm: NgForm): void {
    if (!authForm.valid) {
      return;
    } else {
      ...
      let authObservable: Observable<AuthResponseData>;

      if (this.isLoginMode) {
        authObservable = this.authService.login(email, password);
      } else {
        authObservable = this.authService.signUp(email, password);
      }

      authObservable.subscribe(
        (responseData: AuthResponseData) => {
          console.log(responseData);
          this.isLoading = false;
        },
        (errorMessage: string) => {
          console.log(errorMessage);
          this.error = errorMessage;
          this.isLoading = false;
        }
      );

      authForm.reset();
    }
}
```

### Lesson 298 - Login Error Handling

In `auth.service.ts`

- Refactor the logic used in the `pipe(catchError())` method operator using a private method

```ts
import { ... } from '...';

@Injectable({ providedIn: 'root' })
export class AuthService {
  constructor(private http: HttpClient) {}

  signUp(email: string, password: string): Observable<AuthResponseData> {
    return this.http
      .post<AuthResponseData>( ... )
      .pipe(catchError(this.handleError));
  }

  login(email: string, password: string): Observable<AuthResponseData> {
    return this.http
      .post<AuthResponseData>( ... )
      .pipe(catchError(this.handleError));
      ;
  }

  private handleError(errorResponse: HttpErrorResponse) {
    let errorMessage = 'An unknown error occurred!';
    if (errorResponse?.error?.error) {
      switch (errorResponse.error.error.message) {
        case 'EMAIL_EXISTS': {
          errorMessage = 'This email already exists!';
          break;
        }
        case 'EMAIL_NOT_FOUND': {
          errorMessage = 'This email does not exist!';
          break;
        }
        case 'INVALID_PASSWORD': {
          errorMessage = 'This password is incorrect!';
          break;
        }
      }
    }
    return throwError(errorMessage);
  }
}
```

### Lesson 299 - Creating & Storing the User Data

After the sign-up or login is successful, we'd want to store the user information in our app.

Create a `user.model.ts`. In it

- Define the `User` type that will be used by our app
- Use a getter for the token, and only return the token when the token is not expired

```ts
export class User {
  constructor(
    public email: string,
    public id: string,
    private _token: string,
    private _tokenExpirationDate: Date
  ) {}

  get token() {
    if (!this._tokenExpirationDate || new Date() > this._tokenExpirationDate) {
      return null;
    }
    return this._token;
  }
}
```

In `auth.service.ts`

- Create a `Subject` of type `User` that emits when the user we want to store in our app is updated
- Use the `tap()` RxJS operator to tap into the `Observables` returned by the requests and
  - Construct the new `User` object base on the return data
  - Set the expiration date for the `User` object
  - Emit the `Subject` containing the new `User` information

```ts
import { ... } from '...';

@Injectable({ providedIn: 'root' })
export class AuthService {
  user = new Subject<User>();

  signUp(email: string, password: string): Observable<AuthResponseData> {
    return this.http
      .post<AuthResponseData>( ... )
      .pipe(
        catchError(this.handleError),
        tap((response: AuthResponseData) => {
          this.handleAuthenticationResponse(
            response.email,
            response.localId,
            response.idToken,
            +response.expiresIn
          );
        })
      );
  }

  private handleAuthenticationResponse(
    email: string,
    userId: string,
    token: string,
    expiresIn: number
  ): void {
    const expirationDate = new Date(new Date().getTime() + expiresIn * 1000);
    const user = new User(email, userId, token, expirationDate);
    this.user.next(user);
  }
}
```

### Lesson 300 - Reflecting the Auth State in the UI

Some UI work is required to correctly reflect the user status. E.g. if the user is signed in already, they should not see the Authenticate button in the header section.

In `auth.component.ts`

- Use the Angular `Router` to navigate to the recipes page when the sign-in or sign-up request was successful

```ts
import { ... } from '...';

@Component({ ... })
export class AuthComponent implements OnInit {

  constructor(private authService: AuthService, private router: Router) {}
  ...
  onSubmit(authForm: NgForm): void {
    if (!authForm.valid) {
      return;
    } else {
      ...
      authObservable.subscribe(
        (responseData: AuthResponseData) => {
          ...
          this.router.navigate(['/recipes']);
        },
        (errorMessage: string) => { ...}
      );

    }
  }
}
```

In `header.component.ts`

- Subscribe to the `Subject` in `AuthService` and store if the user is authenticated
- The `!!user` expression is a TS trick that verifies whether the `user` object exists

```ts
import { ... } from 'rxjs';

@Component({ ... })
export class HeaderComponent implements OnInit, OnDestroy {
  isUserAuthenticated = false;
  userSubscription: Subscription;

  constructor(
    private dataStorageService: DataStorageService,
    private authService: AuthService
  ) {}

  ngOnInit(): void {
    this.userSubscription = this.authService.user.subscribe((user: User) => {
      this.isUserAuthenticated = !!user;
    });
  }
  ...
  ngOnDestroy(): void {
    this.userSubscription.unsubscribe();
  }
}

```

In `header.component.html`

- Update the header component using the `isUserAuthenticated` flag to show or hide the header tabs

### Lesson 301 - Adding the Token to Outgoing Requests

To fetch data with the authenticated user, the Token must be attached in the requests. In Firebase, the token is added as a query parameter in the URL.

```txt
https://project-url.firebaseio.com/dataCollection.json?auth=<token>
```

In `auth.service.ts`

- Substitute the User `Subject` with `BehaviorSubject`
- `BehaviorSubject` is a type of `Subject` provided by RxJS that
  - Can still emit and subscribe to data using `BehaviorSubject.next()`
  - Gives subscribers immediate access to the previously emitted value, even though the subscribers have not subscribed at the time the value was emitted
  - Must be initialized with an initial value

```ts
import { ... } from '...';
.,..
@Injectable({ ... })
export class AuthService {
  user = new BehaviorSubject<User>(null);
  ...
}
```

In `data-storage.service.ts`

- In the `fetchRecipes` method

  - Subscribe to the User `BehaviorSubject`
  - Take the data only once using `take`
  - Use the `User.token` to send the GET request to fetch the recipes using `exhaustMap`
  - `map` and `tap` on the resultant Observable for `Recipe[]` as before

- `take(numData: number)` is another RxJS operator.

  - It is used to specify the number of data to receive from the observable.
  - After the number of data is taken from the observable, RxJS will automatically unsubscribe from it.
  - E.g. `Observable.pipe(take(1))`
    - Will take 1 value from the `Observable` and
    - Immediately unsubscribe from `Observable`

- `exhaustMap()` is another RxJS operator.

  - It waits for the observable that the current pipe transforms to complete
  - After that, it takes in a function that
    - Takes in the data from the previous observable as input
    - Return another observable that will replace the previous observable in the observable chain
  - E.g. `Observable<T1>.pipe(exhaustMap((res: T1) => {return Observable<T2>()}))`
    - Exhausts the returned data of type `T1` from the first observable
    - Pass it into a function that returns an observable of type `T2`

```ts
import { ... } from '...';

@Injectable({ ... })
export class DataStorageService {
  ...
  fetchRecipes(): Observable<Recipe[]> {
    return this.authService.user.pipe(
      take(1),
      exhaustMap((user: User) => {
        return this.http.get<Recipe[]>(
          FirebaseConfigs.PROJECT_URL + '/' + FirebaseConfigs.RECIPES_ENDPOINT,
          {
            params: new HttpParams().set(
              FirebaseConfigs.AUTH_QUERY_PARAMETER,
              user.token
            ),
          }
        );
      }),
      map(...),
      tap(...)
    );
  }
}
```

### Lesson 302 - Attaching the Token with an Interceptor

Since all outgoing requests need to have the token attached, it makes sense to do that in an `Interceptor`.

Create `auth-interceptor.service.ts`. In it

- Do not inject by providing the root (`@Injectable({ provideIn: 'root' })`)
- Subscribe to the `user` `BehaviorSubject` in `AuthService`
- Whenever a request is sent
  - Get the current user object from `AuthService.user`
  - If the user object is not yet defined, forward the original request
  - If the user object is defined, update the request to add the token

```ts
@Injectable()
export class AuthInterceptorService implements HttpInterceptor {
  constructor(private authService: AuthService) {}

  intercept(
    req: HttpRequest<any>,
    next: HttpHandler
  ): Observable<HttpEvent<any>> {
    return this.authService.user.pipe(
      take(1),
      exhaustMap((user: User) => {
        if (!user) {
          return next.handle(req);
        } else {
          const modifiedReq = req.clone({
            params: new HttpParams().set('auth', user.token),
          });
          return next.handle(modifiedReq);
        }
      })
    );
  }
}
```

In `app.module.ts`

- Provide the `AuthInterceptorService` and register it as an `HTTP_INTERCEPTORS` type

```ts
@NgModule({
  declarations: [ ... ],
  imports: [ ... ],
  providers: [
    ...,
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptorService,
      multi: true,
    },
  ],
})
export class AppModule {}
```

In `data-storage.service.ts`

- Refactor to adapt the `AuthServiceInterceptor`

```ts
@Injectable({ providedIn: 'root' })
export class DataStorageService {
  ...
  fetchRecipes(): Observable<Recipe[]> {
    return this.http
      .get<Recipe[]>(
        FirebaseConfigs.PROJECT_URL + '/' + FirebaseConfigs.RECIPES_ENDPOINT
      )
      .pipe(
        map(...),
        tap(...)
      );
  }
}
```

### Lesson 303 - Adding Logout

To log a user out, simply reset the `user` object to null in `AuthService`, so everything listening to the `BehaviorSubject` will no longer receive a valid `user`.

In `auth.service.ts`

- Reset the `user` value in the `BehaviorSubject`
- Navigate back to the authentication page when the user is logged out

```ts
@Injectable({
  providedIn: 'root',
})
export class AuthService {
  user = new BehaviorSubject<User>(null);
  ...
  logout() {
    this.user.next(null);
    this.router.navigate(['/auth']);
  }
}
```

In `header.component.ts`

- Add a `onLogout` method that logs the user out

```ts
@Component({ ... })
export class HeaderComponent implements OnInit, OnDestroy {
  onLogout(): void {
    this.authService.logout();
  }
}
```

In `header.component.html`

- Call the `onLogout` method when the user clicks on the Logout button

```html
<li *ngIf="isUserAuthenticated">
  <a style="cursor: pointer;" (click)="onLogout()">Logout</a>
</li>
```
